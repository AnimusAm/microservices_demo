package hr.smilebacksmile.db_client_demo.test_db.domain;



import javax.persistence.*;

@Entity
@Table(name = "testtable")
public class TestData {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    // Two options:
    //
    // Generation type can be set to IDENTITY since underlying DB (MySQL) uses autogenerated ID-s (MySql manages primary keys by autoincrement)
    //      using IDENTITY strategy has a drawback: makes roundtrip to DB every time new ID has to be generated (INSERT for example) - that drawback here is acceptable
    // GenerationType.AUTO with spring.jpa.properties.hibernate.id.new_generator_mappings=false
    //       Specifying GenerationType.AUTO would mean that PKs are generated using sequence
    //      (hibernate decides which strategy to use and usually uses GenerationType.SEQUENCE)
    //          Since current instance of DB doesn't provide any sequence generator, Hibernate will try to use hibernate_sequence table as default (which also does not exist)
    //              That's why spring.jpa.properties.hibernate.id.new_generator_mappings set to false (default is true) is needed
    //              My assumption is that setting it to false makes hibernate (which prefers to use optimised generators, and new_generator_mappings set to true enables usage of optimised generators)
    //                  resign using sequence at all - but that's just the guess
    //          Solution other than this would imply using AUTO or SEQUENCE strategy, but with specifying @TableGenerator annotation pointing to DB table that generates sequence for this table/DB -> meaning, table should also be provided in DB

    // Also, notice that  jpa.hibernate.ddl-auto property is set to no value meaning hibernate will take no action regarding DB schema DLL generation ant point of connecting to it
    private Long id;

    private String code;

    private String name;

    protected TestData() { }

    public TestData(String code, String name) {
        this.code = code;
        this.name = name;
    }

    public Long getId() {
        return id;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "TestData{" +
                "id=" + id +
                ", code='" + code + '\'' +
                ", name='" + name + '\'' +
                '}';
    }
}



